{% load static %}

<style>
.sidebar {
    background: #23243a;
    color: #fff;
    min-width: 220px;
    max-width: 240px;
    height: 100vh;
    transition: transform 0.3s ease;
    box-shadow: 0 0 16px rgba(56,101,255,0.08);
    padding-top: 0.5rem;
    position: fixed;
    top: 0;
    left: 0;
    z-index: 1000;
    overflow-y: auto;
    transform: translateX(0); /* Show by default on desktop */
    width: 240px; /* Ensure consistent width */
    scrollbar-width: none;
    -ms-overflow-style: none;
}
.sidebar::-webkit-scrollbar {
    display: none;
}
.sidebar .logo {
    font-size: 2rem;
    letter-spacing: 1px;
    margin-bottom: 1.5rem;
}
.sidebar nav {
    display: flex;
    flex-direction: column;
    gap: 0.5rem;
    padding: 0 1.2rem;
}
.sidebar nav .nav-link {
    color: #fff;
    font-size: 1.1rem;
    border-radius: 8px;
    display: flex;
    align-items: center;
    gap: 10px;
    padding: 0.6rem 1rem;
    margin-bottom: 2px;
    transition: background 0.2s, font-weight 0.2s;
    text-decoration: none;
}
.sidebar nav .nav-link.active {
    background: #9747FF;
    font-weight: 600;
    box-shadow: 0 2px 8px rgba(151,71,255,0.12);
}
.sidebar nav .nav-link i {
    font-size: 1.2rem;
}
.sidebar nav .nav-link .badge {
    font-size: 0.7rem;
    padding: 0.2rem 0.5rem;
}

.sidebar-status {
    background: rgba(255, 255, 255, 0.03);
    border-top: 1px solid rgba(255, 255, 255, 0.08);
}

.sidebar-status-form {
    background: rgba(255, 255, 255, 0.05);
    border-radius: 14px;
    padding: 1.25rem 1rem;
    box-shadow: 0 6px 18px rgba(0, 0, 0, 0.18);
    backdrop-filter: blur(6px);
}

.status-switch {
    position: relative;
    display: inline-block;
    width: 58px;
    height: 30px;
}

.status-switch input {
    opacity: 0;
    width: 0;
    height: 0;
}

.status-slider {
    position: absolute;
    cursor: pointer;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(255, 255, 255, 0.2);
    transition: all 0.25s ease;
    border-radius: 34px;
    box-shadow: inset 0 2px 6px rgba(0, 0, 0, 0.25);
}

.status-slider::before {
    position: absolute;
    content: "";
    height: 24px;
    width: 24px;
    left: 3px;
    top: 3px;
    background: #ffffff;
    border-radius: 50%;
    transition: all 0.25s ease;
    box-shadow: 0 4px 10px rgba(0, 0, 0, 0.25);
}

.status-switch input:checked + .status-slider {
    background: linear-gradient(135deg, #22c55e 0%, #16a34a 100%);
}

.status-switch input:checked + .status-slider::before {
    transform: translateX(28px);
}

.status-toggle-title {
    font-size: 0.9rem;
    letter-spacing: 0.5px;
}

.status-toggle-state {
    font-weight: 600;
    font-size: 0.85rem;
}

.status-toggle-hint {
    color: rgba(255, 255, 255, 0.6);
}

.status-spinner[hidden] {
    display: none !important;
}

/* Hide sidebar on mobile by default, but keep hamburger visible */
@media (max-width: 768px) {
    .sidebar {
        transform: translateX(-100%); /* Hide on mobile by default */
        width: 280px;
    }

    .sidebar.active {
        transform: translateX(0) !important; /* Show when active - force override */
        z-index: 1001; /* Ensure it's above everything */
    }
}

.sidebar-close {
    position: absolute;
    top: 0.5rem;
    right: 0.5rem;
    background: rgba(255, 255, 255, 0.15);
    color: white;
    border: none;
    border-radius: 50%;
    width: 40px;
    height: 40px;
    font-size: 1.2rem;
    transition: all 0.3s ease;
    display: none; /* Hidden by default */
    z-index: 1003; /* Above everything */
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
}

.sidebar-close:hover {
    background: rgba(255, 255, 255, 0.25);
    transform: scale(1.05);
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
}

/* Show close button when sidebar is active */
.sidebar.active .sidebar-close {
    display: block !important; /* Force show when active */
}
</style>

<div class="sidebar d-flex flex-column">
    <!-- Close button for mobile -->
    <button class="sidebar-close" onclick="toggleSidebar()" aria-label="Close sidebar">
        <i class="fas fa-times"></i>
    </button>

    <h2 class="logo fw-bold text-white text-center py-4">VTS <br><span style="font-weight:400;">Trainer</span></h2>
    <nav class="flex-grow-1">
        <a href="{% url 'trainer_dashboard' %}" class="nav-link{% if request.resolver_match.url_name == 'trainer_dashboard' %} active{% endif %}"><i class="fas fa-home"></i> Dashboard</a>
        <a href="{% url 'trainer_trainee_list' %}" class="nav-link{% if request.resolver_match.url_name == 'trainer_trainee_list' %} active{% endif %}"><i class="fas fa-users"></i> My Trainees</a>
        <a href="{% url 'trainer_trainee_attendance' %}" class="nav-link{% if request.resolver_match.url_name == 'trainer_trainee_attendance' %} active{% endif %}"><i class="fas fa-calendar-check"></i> Mark Attendance</a>
        <a href="{% url 'session_list' %}" class="nav-link{% if request.resolver_match.url_name == 'session_list' %} active{% endif %}"><i class="fas fa-video"></i> Sessions</a>
        <a href="{% url 'trainer_announcements' %}" class="nav-link{% if request.resolver_match.url_name == 'trainer_announcements' %} active{% endif %}">
            <i class="fas fa-bullhorn"></i> Announcements
        </a>
        <a href="{% url 'create_announcement' %}" class="nav-link{% if request.resolver_match.url_name == 'create_announcement' %} active{% endif %}">
            <i class="fas fa-plus-circle"></i> Create Announcement
        </a>
        <a href="{% url 'trainer_logout' %}" class="nav-link"><i class="fas fa-sign-out-alt"></i> Logout</a>
    </nav>

    <div class="sidebar-status px-3 py-4 mt-auto" data-status-endpoint="{% url 'trainer_status_api' %}">
        {% if trainer.admin_locked %}
            <div class="alert alert-warning text-center py-2 mb-0">
                Status locked by admin
            </div>
        {% else %}
            <form method="post" action="{% url 'trainer_dashboard' %}" id="statusForm" class="sidebar-status-form text-center">
                {% csrf_token %}
                <input type="hidden" name="toggle_status" value="toggle">

                <div class="d-flex justify-content-between align-items-center mb-3">
                    <span class="status-toggle-title text-uppercase">Availability</span>
                    <span id="sidebarStatusState" class="status-toggle-state {% if trainer.status == 'Active' %}text-success{% else %}text-warning{% endif %}">
                        {% if trainer.status == 'Active' %}Online{% else %}Offline{% endif %}
                    </span>
                </div>

                <label class="status-switch mb-3">
                    <input type="checkbox" {% if trainer.status == 'Active' %}checked{% endif %} onchange="toggleStatus(this.closest('form'), this);">
                    <span class="status-slider"></span>
                </label>

                <div class="d-flex justify-content-center align-items-center gap-2">
                    <span class="status-toggle-hint">Toggle to change status</span>
                    <div id="statusSpinner" class="status-spinner" hidden>
                        <i class="fas fa-spinner fa-spin text-light"></i>
                    </div>
                </div>
            </form>
        {% endif %}
    </div>
</div>

<script>
    (function () {
        const STATUS_CHANNEL_NAME = 'trainer-status-channel';
        const STORAGE_KEY = 'trainer_status_sync';
        const POLL_INTERVAL_MS = 15000;

        let broadcastChannel = null;
        let pollTimer = null;
        let lastStatus = null;
        let lastAdminLocked = null;
        let initialized = false;

        const refs = {
            sidebarStatus: null,
            form: null,
            checkbox: null,
            spinner: null,
            statusState: null,
            statusBadge: null,
            headerLabel: null,
            statusIcon: null,
            auxBadges: [],
            auxLabels: [],
        };

        function cacheRefs() {
            if (!refs.sidebarStatus) {
                refs.sidebarStatus = document.querySelector('.sidebar-status');
            }
            if (!refs.form) {
                refs.form = document.getElementById('statusForm');
            }
            if (!refs.checkbox && refs.form) {
                refs.checkbox = refs.form.querySelector('input[type="checkbox"]');
            }
            if (!refs.spinner) {
                refs.spinner = document.getElementById('statusSpinner');
            }
            refs.statusState = document.getElementById('sidebarStatusState');
            refs.statusBadge = document.getElementById('trainerStatusBadge');
            refs.headerLabel = document.getElementById('statusLabelText');
            refs.statusIcon = document.getElementById('trainerStatusIcon');
            refs.auxBadges = Array.from(document.querySelectorAll('[data-trainer-status-badge]'));
            refs.auxLabels = Array.from(document.querySelectorAll('[data-trainer-status-label]'));
        }

        function getStatusEndpoint() {
            cacheRefs();
            return refs.sidebarStatus ? refs.sidebarStatus.dataset.statusEndpoint : null;
        }

        function toggleElementClasses(element, classWhenActive, classWhenInactive, isActive) {
            if (!element) {
                return;
            }
            element.classList.toggle(classWhenActive, isActive);
            element.classList.toggle(classWhenInactive, !isActive);
        }

        function applyStatus(status, adminLocked, options = {}) {
            if (!status) {
                return;
            }

            const isActive = status === 'Active';
            const unchanged = status === lastStatus && adminLocked === lastAdminLocked;

            if (unchanged && !options.force) {
                return;
            }

            lastStatus = status;
            lastAdminLocked = !!adminLocked;

            cacheRefs();

            if (refs.checkbox) {
                refs.checkbox.checked = isActive;
                refs.checkbox.disabled = !!adminLocked;
            }

            const stateText = adminLocked ? 'Offline (Admin)' : (isActive ? 'Online' : 'Offline');
            const stateKey = adminLocked ? 'locked' : (isActive ? 'active' : 'inactive');

            if (refs.statusState) {
                refs.statusState.textContent = stateText;
                refs.statusState.classList.remove('text-success', 'text-warning', 'text-danger');
                if (adminLocked) {
                    refs.statusState.classList.add('text-danger');
                } else if (isActive) {
                    refs.statusState.classList.add('text-success');
                } else {
                    refs.statusState.classList.add('text-warning');
                }
            }

            if (refs.statusBadge) {
                refs.statusBadge.classList.remove('is-active', 'is-offline', 'is-locked');
                if (adminLocked) {
                    refs.statusBadge.classList.add('is-locked');
                } else {
                    refs.statusBadge.classList.add(isActive ? 'is-active' : 'is-offline');
                }
                const badgeLabel = refs.statusBadge.querySelector('[data-trainer-status-label]');
                if (badgeLabel) {
                    badgeLabel.textContent = stateText;
                }
            }

            if (refs.statusIcon) {
                refs.statusIcon.className = 'fas ' + (adminLocked ? 'fa-lock' : (isActive ? 'fa-circle-check' : 'fa-circle-minus'));
            }

            if (refs.headerLabel) {
                refs.headerLabel.textContent = stateText;
            }

            if (refs.auxBadges.length) {
                refs.auxBadges.forEach(badge => {
                    const activeClass = badge.dataset.activeClass || '';
                    const inactiveClass = badge.dataset.inactiveClass || '';
                    const lockedClass = badge.dataset.lockedClass || '';
                    [activeClass, inactiveClass, lockedClass].forEach(cls => {
                        if (cls) {
                            badge.classList.remove(cls);
                        }
                    });

                    if (stateKey === 'locked' && lockedClass) {
                        badge.classList.add(lockedClass);
                    } else if (stateKey === 'active' && activeClass) {
                        badge.classList.add(activeClass);
                    } else if (inactiveClass) {
                        badge.classList.add(inactiveClass);
                    }

                    const inlineLabel = badge.querySelector('[data-trainer-status-label]');
                    if (inlineLabel) {
                        inlineLabel.textContent = stateText;
                    }
                });
            }

            if (refs.auxLabels.length) {
                refs.auxLabels.forEach(label => {
                    label.textContent = stateText;
                });
            }

            if (refs.form) {
                refs.form.classList.toggle('status-admin-locked', !!adminLocked);
            }

            if (!options.silent) {
                broadcastStatus(status, !!adminLocked);
            }
        }

        function broadcastStatus(status, adminLocked) {
            const payload = {
                status,
                admin_locked: !!adminLocked,
                ts: Date.now(),
            };

            if (broadcastChannel) {
                try {
                    broadcastChannel.postMessage(payload);
                    return;
                } catch (_) {
                    // fall back to storage event
                }
            }

            try {
                localStorage.setItem(STORAGE_KEY, JSON.stringify(payload));
                // Removing the item allows repeated events in some browsers
                localStorage.removeItem(STORAGE_KEY);
            } catch (_) {
                // Ignore storage quota errors
            }
        }

        function handleBroadcastMessage(event) {
            const data = event && event.data ? event.data : event;
            if (!data || !data.status) {
                return;
            }
            applyStatus(data.status, data.admin_locked, { silent: true });
        }

        function fetchLatestStatus(force = false) {
            const endpoint = getStatusEndpoint();
            if (!endpoint) {
                return;
            }

            fetch(endpoint, {
                headers: { 'X-Requested-With': 'XMLHttpRequest' },
                credentials: 'same-origin',
            })
                .then(response => response.ok ? response.json() : null)
                .then(data => {
                    if (!data || !data.status) {
                        return;
                    }
                    applyStatus(data.status, data.admin_locked, { silent: true, force });
                })
                .catch(error => {
                    console.error('Trainer status poll failed:', error);
                });
        }

        function schedulePolling() {
            if (pollTimer) {
                clearInterval(pollTimer);
            }
            pollTimer = setInterval(fetchLatestStatus, POLL_INTERVAL_MS);
        }

        function ensureBroadcastTransport() {
            if ('BroadcastChannel' in window) {
                broadcastChannel = new BroadcastChannel(STATUS_CHANNEL_NAME);
                broadcastChannel.addEventListener('message', handleBroadcastMessage);
            } else {
                window.addEventListener('storage', function (event) {
                    if (event.key === STORAGE_KEY && event.newValue) {
                        try {
                            const data = JSON.parse(event.newValue);
                            handleBroadcastMessage(data);
                        } catch (_) {
                            // Ignore JSON parsing errors
                        }
                    }
                });
            }
        }

        function showStatusAlert(isSuccess, message) {
            const container = document.getElementById('statusAlertContainer');
            if (!container) {
                console[isSuccess ? 'info' : 'warn'](message);
                return;
            }

            container.innerHTML = '';
            const alertDiv = document.createElement('div');
            alertDiv.className = `alert alert-${isSuccess ? 'success' : 'danger'} alert-dismissible fade show`;
            alertDiv.setAttribute('role', 'alert');
            alertDiv.innerHTML = `${message}<button type="button" class="btn-close" data-bs-dismiss="alert"></button>`;

            container.appendChild(alertDiv);

            setTimeout(() => {
                if (!alertDiv || !alertDiv.parentElement) {
                    return;
                }
                if (window.bootstrap && window.bootstrap.Alert) {
                    const alertInstance = window.bootstrap.Alert.getOrCreateInstance(alertDiv);
                    alertInstance.close();
                } else {
                    alertDiv.remove();
                }
            }, 3000);
        }

        function handleToggle(source, control) {
            cacheRefs();
            const form = source instanceof HTMLFormElement ? source : refs.form;
            if (!form) {
                return;
            }

            const checkbox = control && control.tagName === 'INPUT' ? control : refs.checkbox;
            const spinner = refs.spinner;
            const originalChecked = checkbox ? checkbox.checked : null;

            if (checkbox) {
                checkbox.disabled = true;
            }
            if (spinner) {
                spinner.hidden = false;
            }

            const csrfInput = form.querySelector('input[name="csrfmiddlewaretoken"]');
            const formData = new FormData(form);
            const headers = { 'X-Requested-With': 'XMLHttpRequest' };

            if (csrfInput) {
                headers['X-CSRFToken'] = csrfInput.value;
            }

            fetch(form.action, {
                method: 'POST',
                body: formData,
                headers,
                credentials: 'same-origin',
            })
                .then(async response => {
                    const data = await response.json().catch(() => null);
                    return { ok: response.ok, data };
                })
                .then(result => {
                    const { ok, data } = result;

                    if (!data || typeof data.success === 'undefined') {
                        throw new Error('Unexpected response payload');
                    }

                    if (!ok || !data.success) {
                        if (checkbox && originalChecked !== null) {
                            checkbox.checked = originalChecked;
                        }
                        showStatusAlert(false, data.message || 'Unable to update status.');
                        return;
                    }

                    applyStatus(data.new_status, data.admin_locked, { silent: false, force: true });
                    showStatusAlert(true, data.message || 'Status updated successfully.');
                })
                .catch(error => {
                    console.error('Status toggle failed:', error);
                    if (checkbox && originalChecked !== null) {
                        checkbox.checked = originalChecked;
                    }
                    showStatusAlert(false, 'Something went wrong. Please try again.');
                })
                .finally(() => {
                    if (checkbox) {
                        checkbox.disabled = !!lastAdminLocked;
                    }
                    if (spinner) {
                        spinner.hidden = true;
                    }
                });
        }

        function initialize() {
            if (initialized) {
                return;
            }
            initialized = true;

            cacheRefs();
            ensureBroadcastTransport();
            fetchLatestStatus(true);
            schedulePolling();

            document.addEventListener('visibilitychange', function () {
                if (!document.hidden) {
                    fetchLatestStatus(true);
                }
            });

            if (refs.form) {
                refs.form.addEventListener('submit', function (event) {
                    event.preventDefault();
                    handleToggle(refs.form, refs.checkbox);
                });
            }
        }

        document.addEventListener('DOMContentLoaded', initialize);

        window.toggleStatus = handleToggle;
        window.showStatusAlert = showStatusAlert;
        window.applyTrainerStatusUI = function (status, adminLocked, options) {
            applyStatus(status, adminLocked, options || { silent: true });
        };
    })();
</script>
